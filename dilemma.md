# A Web Developers Dilemma

So you want to make really cool web applications. Congratulations! But now, where to begin? Well, do some searching and you might stumble upon responsive web design, mobile-first principles, and you'll probably learn quickly that HTML(5), CSS(3), JavaScript (especially jQuery) and maybe some PHP if you need to get fancy will suit you. How wrong thou art. That set of tools will get you far in many cases, especially if the information for the application doesn't change, and even if it does all you have to do is edit an HTML file or two. Easy. But what about something like Facebook, Twitter or Instagram? Is that all just HTML, CSS and JavaScript? Yes and no. Yes in the sense that your browser gets just those things when it sends a request but no in the sense that someone sits there and manually edits your profile after you send in an update: that would make those applications un-manageably expensive. 

## From Django to Rails

Every time I pick up some Rails, I am remiss: I love Python, I love Django and somehow liking both presents in my mind a sort of existensial crisis. Ruby is a wonderful language that lends itself to web development in an intuitive way: no need to understand the logic of Relational Databases; simply put a 'has_many' or 'belongs_to' and you're set. Want to run a migration? No problem, Rails let's me do database commands in a pinch: no "python manage.py schemamigration --auto" just 'rails db:migrate.' Don't get me started on the wonders of scaffolds. But at the end of the day, when you want to get someone on boarded to a Rails project, they have to sift thorough an entire app directory, analyze the gemfile, bundle install (cross your fingers) and hopefully there is at least a little documentation to shed a light on the mess that is the Rails app directory structure.

### Don't Repeat Yourself
No programmer likes the act of programming: if I could just will my code into existence I would get so much more done. Both Django and Rails adhere to this principle of writing the least amount of code possible with sensible defaults and a "batteries included" mentality. No header files with cyriptic #ifnotdef horrors of the C/C++ tradition but all the speed and power built-in to the interpreter. I don't want to discuss performance because I'm not a computer scientist and frankly flops can be formidible foes with N+1 queries and big-O's: blech. I digress. Both Ruby and Python share the notion that making life easy on the coder is the simplest way to progress the software to new heights. Python looks better, hands down. I can show a novice programmer some Python code and they can tell me what it does with little to no explanation. Ruby, on the other hand, takes some getting used to but man is it cool. Having question marks and exclamation points on methods is a stroke of genius: no need to bother looking at a return type or some other nonsense that isn't really necessary with duck-typing.

### Modular App-rithmetic
Here's the thing that makes me love Django above all else: the idea of an app in a django project is a python module that contains a set of models, views, urls, templates, forms, templatetags, etc. that perform a well defined minimum set of functionality. For example, if I want to handle user authentication I might just make an app called 'user_auth' that has all of the login/logout, signup, confirmation emails and API calls for social media authentication all in one place. In Django this idea is expressed via 'loose-coupling' so that once an app is developed, it can be reused without a lot of wiring. In the Ruby on Rails world, this is essentially the same as breaking the contents of the App directory (along with it's dependencies) into separate gems. Simple. So my Django project (the application as a whole) is highly modular and therefore easier to understand how all the parts fit together. 

### Convention over Configuration
Rails is a highly mature MVC framework that practically defines the framework. Django, by comparison, is young to this world. It is easy to pick-up the basics for each and a struggle to get beyond (this one is for the Django people) the polls tutorial. For me, Django's beauty comes from how familiar the code feels - Classed Based Views, urlconfs, the forms, it all has the air of 'you can do this' until you want to do something like add a form to a detail view. In which case, good luck. You have to get a bit creative to do something like that but luckily everything lives in Django's documentation (including a couple solutions to that problem).